import qs from 'query-string';
import {createRoutes} from 'react-router';
import React from 'react';

import Util from './Util';

function findRedirect(queryString) {
  let redirectTo = false;

  Object.keys(queryString).forEach(function (key) {
    if (/redirect/.test(key)) {
      redirectTo = queryString[key];
    }
  });

  return redirectTo;
}

const RouterUtil = {

  getRedirectTo() {
    let redirectTo = false;

    // This will match url instances like this:
    // /?redirect=SOME_ADDRESS#/login
    if (global.location.search) {
      redirectTo = findRedirect(qs.parse(global.location.search));
    }

    // This will match url instances like this:
    // /#/login?redirect=SOME_ADDRESS
    if (!redirectTo && global.location.hash) {
      redirectTo = findRedirect(qs.parse(global.location.hash));
    }

    return redirectTo;
  },

  /**
   * Creates a tree of React components for an array of route configurations
   *
   * @param  {Array} routes
   * @return {Array} React tree of routes
   */
  createComponentsFromRoutes(routes) {
    return routes.map(function (route) {
      let args = [route.type, Util.omit(route, ['type', 'children'])];

      if (route.children) {
        let children = RouterUtil.createComponentsFromRoutes(route.children);
        args = args.concat(children);
      }
      return React.createElement(...args);
    });
  },

  /**
   * Sets missing configuration properties to the routes that are generated by
   * react router. This is needed because react router will strip those out.ยก
   *
   * @param  {Array} routes of Route instances
   * @param  {Array} originalRoutes of original route configuration
   * @return {Array} Modified routes with original configuration
   */
  setRouteConfiguration(routes, originalRoutes) {
    return routes.map(function (route, index) {
      let originalConfiguration = originalRoutes[index];

      if (!originalConfiguration) {
        return route;
      }

      if (route.childRoutes && originalConfiguration.children) {
        route.childRoutes = RouterUtil.setRouteConfiguration(
          route.childRoutes, originalConfiguration.children
        );
      }

      // Transfer any property that is not already present on route,
      // but available in originalConfiguration
      Object.keys(originalConfiguration).forEach(function (prop) {
        if (!Object.prototype.hasOwnProperty.call(route, prop)) {
          route[prop] = originalConfiguration[prop];
        }
      });

      if (originalConfiguration.hideHeaderNavigation) {
        route.hideHeaderNavigation = originalConfiguration.hideHeaderNavigation;
      }

      return route;
    });
  },

  /**
   * Builds a route array that react router can use,
   * with the correct configuration.
   *
   * @param  {Array} originalRoutes Original Route configuration
   * @return {Array} Routes ready to use by react router
   */
  buildRoutes(originalRoutes) {
    let elementRoutes = RouterUtil.createComponentsFromRoutes(originalRoutes);
    let routes = createRoutes(elementRoutes[0]);

    return RouterUtil.setRouteConfiguration(routes, originalRoutes);
  },

  /**
   * Checks if a page should hide the header navigation tabs
   * @param  {Array} routes instance of react-router
   * @return {Bool} should hide Page Navigation
   */
  shouldHideNavigation(routes) {
    return !!routes[routes.length - 1].hideHeaderNavigation;
  }

};

module.exports = RouterUtil;
